{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "var sst = function(hours,route,trains,seed) {\n\n// platform\nfunction Platform(station, leftBound) {\n    this.queue = [];\n    this.leftBound = leftBound;\n    this.station = station;\n    this.tickCount = 0; // keep track to allow time-dependent passenger creation\n    this.waitTimes = []; // array of current time spent waiting\n    this.shouldGeneratePassengers = true; // default to loading passengers\n\n\n    this.lambda = function() {\n        return 2000;\n    }\n\n    this.push = function(person) {\n        return this.queue.push(person);\n    };  \n\n\n    // make the passengers board the given train\n    this.board = function(train) {\n        // determine how many passengers can board given train\n        cap = train.passengerSpace();\n\n        // take the fitting number of passengers off of the queue and waitTimes\n        boardingPassengers = this.queue.slice(0,cap-1);\n        this.queue = this.queue.slice(cap, this.queue.length);\n        this.waitTimes = this.waitTimes.slice(cap, this.waitTimes.length);\n\n\n\n        // pass the boarding passengers to the train\n        train.board(boardingPassengers);\n\n    }\n\n    this.tick = function() {\n        // generate passengers to enter the queue\n        newPass = this.generatePassengers();\n\n\n\n        // tick the passengers\n        this.setWaitTimes(newPass);\n\n        this.tickCount += 1;\n    }\n\n    this.setWaitTimes = function(newPass) {\n        wt = this.waitTimes;\n        for (i = 0, len = this.waitTimes.length; i < len; i++) {\n            wt[i] += 1;\n        }\n        // add new data point if new passenger was generated\n        if (newPass) {\n            wt.push(0);\n        }\n    }\n\n    // generatePassengers creates a number of passengers and inserts them into the queue based on the platform's Poisson process\n    this.generatePassengers = function() {\n        // if this is the last platform in a given direction, don't generate passengers\n        if (this.shouldGeneratePassengers ) {\n            // process governing passener creation\n            if (Math.random() < this.lambda() / (60 * 60)) { // assumes hourly lambda\n                this.push(new Passenger(this.tickCount));\n                return true\n            }\n\n            // Deterministic passenger creation\n            // if (this.tickCount % 2 === 0){\n            //     this.push(new Passenger(this.tickCount));\n            //     return true;\n            // }\n            return false;\n        }\n    }\n}\n\n// Passenger\nfunction Passenger(tick) {\n\n    this.creationTime = tick;\n    this.enter = function(place) {\n        if (place instanceof Platform) {\n            place.push(this);\n        } else if (place instanceof Train) {\n            // Decide where to get off next\n        } else {\n            // error\n            console.log(\"Error in passenger entering place.\");\n        }\n    }\n\n    this.gettingOff = function(Station) {\n        // eventually could decide if this is the station they want to get off at\n        // for now, return true each time\n        return true;\n    }\n\n\n\n}\n\n// Train\nfunction Train(id,startSeg, leftBound, pauseTicks) {\n    this.id = id;\n    this.passengers = []; // an array to hold the passengers on the train\n\n    this.pauseTicks = pauseTicks || 0; // the default time to wait at a location, in ticks\n    this.speed = 45000; // in meters/hour\n    this.capacity = 500;\n\n    this.leftBound = leftBound;\n    this.currentSegment = startSeg;\n    this.boarded = false;\n    this.ready = false;\n    this.distanceOnTrack = 0;\n\n\n    this.nextSegment = function() {\n        if (this.leftBound) {\n            return this.currentSegment.left;\n        } else {\n            return this.currentSegment.right;\n        }\n    }\n\n\n    // return how many more passengers can fit\n    this.passengerSpace = function() {\n        return this.capacity - this.passengers.length;\n    }\n\n\n    // return array of the passengers that are getting off\n    this.disembark = function(station) {\n        exitingPassengers = [];\n        remainingPassengers = [];\n\n        // put passengers in their appropriate place\n        for (i = this.passengers.length - 1; i >= 0; i--) {\n            if (this.passengers[i].gettingOff(station)) {\n                exitingPassengers.push(this.passengers[i]);\n            } else {\n                remainingPassengers.push(this.passengers[i]);\n            }\n        }\n\n        // set those still on the train as the remaining passengers\n        this.passengers = remainingPassengers;\n        //make train wait based on number of passengers getting off\n        this.pauseTicks += ( exitingPassengers.length + 100) / 10; // chosen to have a baseline of 10 seconds for stop, with a max of 60 seconds if 500 passengers getting off\n\n        return exitingPassengers;\n    }\n\n    // take the passengers getting on and decide how long it will take to board them\n    this.board = function(pass) {\n        this.pauseTicks += (4 * pass.length + 250) / 25 ; // chosen to have a baseline of 10 seconds for stop, with a max of ~1.5 minutes if 500 passengers getting on\n        this.passengers = this.passengers.concat(pass); // add the boarding passengers to list of those already onboard\n    }\n\n\n    this.stationProcedures = function() {\n        if (!this.boarded) {\n            // initiate unload/unload procedure\n            this.currentSegment.here.arrive(this); // station will tell train how long to wait\n\n            // console.log(\"train heading\", direction, \" with \", this.passengers.length, \" passengers\");\n            this.boarded = true;\n        }\n        if (this.pauseTicks < 1) {\n            // time for the train to leave the station\n            this.distanceOnTrack = 0;\n            this.boarded = false;\n            this.ready = true;\n\n        } else {\n            this.pauseTicks--;\n        }\n    }\n\n\n\n    this.terminusProcedures = function() {\n\n        if (this.pauseTicks < 1) {\n            // time for the train to leave the station\n            this.leftBound = !this.leftBound;\n            this.distanceOnTrack = 0;\n            this.boarded = false;\n            this.ready = true;\n        } else {\n            this.pauseTicks--;\n        }\n\n    }\n    this.currentProcedure = this.terminusProcedures; // trains start at terminus\n\n    this.trackProcedures = function() {\n        if ((this.currentSegment.kind.length - this.distanceOnTrack) - this.speed / 60 / 60 <= 0) {\n            // train ready to proceed\n            this.ready = true;\n        }\n        // add this speed so that it can partially travel on next track segment\n        this.distanceOnTrack += this.speed / 60 / 60;\n    }\n\n\n\n    this.makeNotReady = function() {\n        this.ready = false;\n    }\n\n    this.tick = function() {\n        if (this.ready) {\n            //travel\n            this.travel();\n        } else {\n            // continue process until ready\n            this.currentProcedure();\n        }\n\n    }\n\n    this.travel = function() {\n        nextSeg = this.nextSegment();\n        headingLeft = this.leftBound;\n        if (nextSeg.safeToProceed(headingLeft)) {\n            //  proceed\n            this.currentSegment.trainExit(this);\n            this.currentSegment = nextSeg;\n            this.currentSegment.trainEnter(this);\n        } else {\n            // don't proceed\n        }\n    }\n\n}\n\nfunction Route(leftMost, rightMost) {\n    //both should be terminus\n    this.leftMost = leftMost;\n    this.rightMost = rightMost;\n\n\n    // interpolateAttractiveness\n    // based on given station attractiveness, interpolate other station values\n    this.interpolateAttractiveness = function() {\n        var cur = this.leftMost;\n        var stationCount = 0;\n        //create array of attractiveness values\n        attr = [];\n\n        while (cur) {\n            if (cur.here instanceof Station) {\n                if (cur.here.attractiveness) {\n                    attr[stationCount] = cur.here.attractiveness;\n                } else {\n                    attr[stationCount] = undefined;\n                }\n                stationCount += 1;\n            }\n            cur = cur.right;\n        }\n        // interpolate missing values, with min being the value to interpolate from if not bounded\n        var linearInt = function(arr,min) {\n            for (i = 0, len = arr.length; i < len; i++) {\n                if (!arr[i]) {\n                    a = arr[i-1] || min;\n                    b = arr[i+1] || min;\n                    arr[i] = a + (b-a)/2;\n                }\n            }\n            return arr;\n        }\n        // interpolate missing values\n        attr = linearInt(attr,.1);\n\n        // loop back through and assign attractiveness\n        cur = this.leftMost;\n        stationCount = 0;\n        while (cur) {\n            if (cur.here instanceof Station) {\n\n                cur.here.attractiveness = attr[stationCount];\n                stationCount += 1;\n            }\n            cur = cur.right;\n        }\n\n    }\n\n    // insertAfter(RouteSegment, RouteSegment )\n    // Insert a RouteSegment, seg, to the left of the leftmost location\n    this.insertAfter = function(seg, newSeg) {\n        newSeg.left = seg;\n        newSeg.right = seg.right;\n\n        if (seg.right instanceof Terminus) {\n            this.rightMost = newSeg;\n        } else {\n            seg.right.left = newSeg;\n        }\n    }\n\n    // insertAfter(RouteSegment, RouteSegment )\n    // Insert a RouteSegment, seg, to the left of the leftmost location\n    this.insertBefore = function(seg, newSeg) {\n        newSeg.left = seg.left;\n        newSeg.right = seg;\n\n        if (!seg.left) { // is left null?\n            this.leftMost = newSeg;\n            seg.left = newSeg;\n        } else {\n            seg.left.right = newSeg;\n        }\n    }\n\n    // insertBeginning(first node)\n    // Insert the first item into the Route\n    this.insertBeginning = function(newSeg) {\n        if (!this.leftMost) { // is leftmost null?\n            this.leftMost = newSeg;\n            this.rightMost = newSeg;\n        } else {\n            this.insertBefore(this.leftMost,newSeg);\n        }\n        return newSeg;\n    }\n\n    // print route\n    this.printRoute = function() {\n        // print left to right\n        console.log(\"-------- left to right ----\");\n        cur = this.leftMost;\n        while (!(cur instanceof Terminus) || !cur) {\n            console.log(cur.kind);\n            cur = cur.right;\n        }\n        console.log(\"------- right to left ----\");\n\n        // print right to left\n        cur = this.rightMost;\n        while (!(cur instanceof Terminus) || !cur) {\n            console.log(cur.kind);\n            cur = cur.left;\n        }\n    }\n\n    // tick the route forward in time\n    this.tick = function() {\n        cur = this.leftMost;\n        while (cur) {\n            cur.tick();\n            cur = cur.right;\n        }\n    }\n}\n\n// Route\n// A route is one of: a RouteSegment, a Terminus\nfunction RouteSegment(here, left, right) {\n    this.here = here; // The first here should be a terminus\n    this.left = left;\n    this.right = right;\n    this.kind = this.here;\n    here.addParentSegment(this);\n\n    this.trainEnter = function(train) {\n        this.kind.trainEnter(train);\n    }\n\n    this.trainExit = function(train) {\n        this.kind.trainExit(train);\n    }\n\n    this.safeToProceed = function(left) {\n        return this.kind.safeToProceed(left); // ask what's here\n    }\n\n    // What is the distance from the left up to and including seg\n    this.distanceFromLeft = function(seg) {\n        distance = 0;\n        cur = this.leftMost();\n        while (cur !== seg) {\n            if (cur.here.length) {\n                distance += cur.here.length;\n            }\n            cur = cur.right;\n        }\n        return distance;\n    }\n\n    // return the leftMost station\n    this.leftMost = function() {\n        if (!this.left) {\n            // if left is null, this is terminus, so return one right\n            return this;\n        } else {\n            return this.left.leftMost();\n        }\n    }\n\n    // return the rightMost station\n    this.rightMost = function() {\n        if (!this.right) {\n            // if right is null, this is terminus, so return one left\n            return this;\n        } else {\n            return this.right.rightMost();\n        }\n    }\n\n    // pass the tick onto this node's location\n    this.tick = function() {\n        this.here.tick();\n    }\n}\n\n// Track\n// A track is a distance that the train must travel in between stations\nfunction Track(len) {\n    this.length = len;\n    this.hasLeftBoundTrain = false;\n    this.hasRightBoundTrain = false;\n\n    this.trainEnter = function(train) {\n        if (train.leftBound) {\n            this.hasLeftBoundTrain = true;\n        } else {\n            this.hasRightBoundTrain = true;\n        }\n        train.distanceOnTrack += train.speed / 60 / 60; // give train boost equal to one tick to make up for losing turn on travel\n        train.ready = false;\n        train.currentProcedure = train.trackProcedures;\n    }\n\n    this.trainExit = function(train) {\n        train.distanceOnTrack -= this.length; // reset distance traveled on segment\n        if (train.leftBound) {\n            this.hasLeftBoundTrain = false;\n        } else {\n            this.hasRightBoundTrain = false;\n        }\n    }\n\n    this.tick = function() {\n        // do nothing\n    }\n\n    this.addParentSegment = function(seg) {\n        this.routeSeg = seg;\n    }\n    this.safeToProceed = function(left) {\n        if (left) {\n            return !this.hasLeftBoundTrain;\n        } else {\n            return !this.hasRightBoundTrain;\n        }\n    }\n\n}\n\n// Station\n// A Station is where passengers may board and exit the train\nfunction Station(id, attractiveness) {\n    this.attractiveness = attractiveness; // should be between 0 and 1\n    this.id = id;\n    this.hasLeftBoundTrain = false;\n    this.hasRightBoundTrain = false;\n    this.leftBoundPlatform = new Platform(this, true);\n    this.rightBoundPlatform = new Platform(this, false);\n\n    this.trainEnter = function(train) {\n        if (train.leftBound) {\n            this.hasLeftBoundTrain = true;\n        } else {\n            this.hasRightBoundTrain = true;\n        }\n        train.ready = false;\n        train.currentProcedure = train.stationProcedures;\n    }\n\n    this.trainExit = function(train) {\n        if (train.leftBound) {\n            this.hasLeftBoundTrain = false;\n        } else {\n            this.hasRightBoundTrain = false;\n        }\n    }\n\n    // arrive takes a train and initiates procedures to make passengers get off and board the train\n    this.arrive = function(train) {\n\n        // disembark passengers off train\n        ////////////////\n\n        passengers = train.disembark(this); // An array of the passengers exiting\n\n        // make passengers waiting on platform board train\n        /////////////\n\n        if (train.leftBound) {\n            // board passengers on leftBound Platform\n            this.leftBoundPlatform.board(train);\n        } else {\n            // //board passengers on rightBound Platform\n            this.rightBoundPlatform.board(train);\n        }\n\n    }\n\n    this.tick = function() {\n        // tick each platform\n        this.leftBoundPlatform.tick();\n        this.rightBoundPlatform.tick();\n\n    }\n\n    this.safeToProceed = function(left) {\n        if (left) {\n            return !this.hasLeftBoundTrain;\n        } else {\n            return !this.hasRightBoundTrain;\n        }\n    }\n    this.addParentSegment = function(seg) {\n        this.routeSeg = seg;\n    }\n}\n\n\n\n// Terminus\n// A Terminus is a the area past the last station on a side\n// Functions as 'null'\nfunction Terminus() {\n    this.hasLeftBoundTrain = false;\n    this.hasRightBoundTrain = false;\n    this.trainEnter = function(train) {\n        if (train.leftBound) {\n            this.hasLeftBoundTrain = true;\n        } else {\n            this.hasRightBoundTrain = true;\n        }\n\n        train.ready = false;\n        train.pauseTicks = 120; // wait two minutes before turning around\n        train.currentProcedure = train.terminusProcedures;\n    }\n\n    this.trainExit = function(train) {\n        if (train.leftBound) {\n            this.hasLeftBoundTrain = false;\n        } else {\n            this.hasRightBoundTrain = false;\n        }\n    }\n    this.safeToProceed = function() {\n        return true; // assume that the end of the line can handle multiple trains\n    }\n\n    this.addParentSegment = function(seg) {\n        this.routeSeg = seg;\n    }\n    this.tick = function() {\n        return;\n    }\n}\n\n// Useful functions\nfunction sumArray(arr) {\n    sum = 0;\n    for (var i = 0, len = arr.length; i < len; i++) {\n        sum += arr[i];\n    }\n\n    return sum;\n}\n\nfunction meanArray(arr) {\n    sum = sumArray(arr);\n    return sum/arr.length;\n}\n\n// World\n// A place to keep track of all of the objects\nfunction World() {\n    // A World starts with a Station\n    this.line = new Route();\n    this.stations = [];\n    this.trains = [];\n    this.tickCount = 0;\n    this.tick = function() {\n        //tick the world forward\n        this.tickCount += 1;\n        // tick the stations\n        this.line.tick();\n\n        // tick the trains\n        for (trainNum = this.trains.length - 1 ; trainNum >= 0; trainNum--) {\n            this.trains[trainNum].tick();\n        }\n\n\n\n    }\n\n    //wrapper for convienent distance calcs\n    this.distanceFromLeft = function(seg) {\n        return this.line.rightMost.distanceFromLeft(seg);\n    }\n\n    // return how far from the left the train is\n    this.trainLocation = function(train) {\n        if (train.leftBound) {\n                //train is heading left, so subtract distance traveled on segment\n                return this.distanceFromLeft(train.currentSegment.right) - train.distanceOnTrack;\n            } else {\n                // train is heading right, so subtract distance left to go\n                return this.distanceFromLeft(train.currentSegment) + train.distanceOnTrack;\n            }\n        }\n\n    // return array of where trains are located\n    this.trainLocations = function() {\n        i = this.trains.length -1;\n        dist = [];\n        // go through each train\n        while (i >= 0) {\n            train = this.trains[i];\n            dist.push(this.trainLocation(train));\n            // go to next train\n            i--\n        }\n        return dist;\n    }\n\n    this.addTrainAtTick = function(tick, starOnLeftB) {\n        if (starOnLeftB) {\n         this.trains.push(new Train(this.trains.length, this.line.leftMost, true, tick));\n     } else {\n         this.trains.push(new Train(this.trains.length, this.line.rightMost, false, tick));\n     }\n }\n\n    // add a route to the world based on the passed on route\n    this.generateRoute = function(route) {\n\n        // build the route right to left\n\n        var stationCount = 0;\n\n        //insert start terminus\n        this.line.insertBeginning(new RouteSegment(new Terminus()));\n\n        for (var i = 0, len = route.length; i < len; i++) {\n            if (route[i].kind === 'station') {\n                stationSeg = this.line.insertBeginning(new RouteSegment(new Station(stationCount, route[i].attractiveness)));\n                this.stations[stationCount] = stationSeg.here; // add the created station to the easy-to-access array of stations\n                stationCount += 1\n\n            }\n            if (route[i].kind === 'track') {\n                this.line.insertBeginning(new RouteSegment(new Track(route[i].trackLength)));\n            }\n        }\n\n        // insert end terminus\n        this.line.insertBeginning(new RouteSegment(new Terminus()));\n\n        // disable passenger generation at two end platforms\n        this.line.leftMost.right.here.leftBoundPlatform.shouldGeneratePassengers = false;\n        this.line.rightMost.left.here.rightBoundPlatform.shouldGeneratePassengers = false;\n\n    }\n    // add trains to the world based on the array of train options passed\n    this.generateTrains = function(trains) {\n        // generate trains\n        // trains number of trains has to be set in the beginning, so that the data container can be set up properly\n        for (var i = 0, len = trains.length; i < len; i++) {\n            this.addTrainAtTick(trains[i].startTime, trains[i].startOnLeft )\n        }\n    }\n}\n\n// Run the model\ngetSimulationData = function(hours,route,trains,seed){\n\n    // if seed exists, use it, else just store the generated seed\n    if (seed) {\n        randomSeed = Math.seedrandom(seed);\n    } else {\n        randomSeed = Math.seedrandom();\n    }\n    sst = new World();\n\n\n    sst.generateRoute(route);\n    sst.line.interpolateAttractiveness(); // set attractiveness for each station\n\n    sst.generateTrains(trains);\n\n    // Begin ticking the world\n    totalTicks = hours * 60 * 60;\n\n    // set up data container\n    data = {\n        stations: [],\n        trains: [],\n        seed : randomSeed,\n    }\n\n    var stationCount = sst.stations.length;\n    var trainCount = sst.trains.length;\n\n    //set up train data object\n    for (var trainNum = 0; trainNum < trainCount; trainNum++) {\n        data.trains[trainNum] = {\n            leftDist: [],\n            };\n        }\n\n    // set up station data object\n    for (var statNum = 0; statNum < stationCount; statNum++) {\n        data.stations[statNum] = {\n            leftBound: {\n                waitTimes : [],\n                queueLength : [],\n            },\n            rightBound: {\n                waitTimes : [],\n                queueLength : [],\n            },\n        };\n    }\n\n\n\n        for (t = 0; t < totalTicks ; t++) {\n        //tick the world forward\n        sst.tick();\n\n        // collect data\n        ////////////////////////////\n\n        // station data\n        for (var statNum = 0; statNum < stationCount; statNum++) {\n            d = data.stations[statNum];\n            s = sst.stations[statNum];\n            d.leftBound.waitTimes.push(sumArray(s.leftBoundPlatform.waitTimes));\n            d.leftBound.queueLength.push(s.leftBoundPlatform.queue.length);\n            d.rightBound.waitTimes.push(sumArray(s.rightBoundPlatform.waitTimes));\n            d.rightBound.queueLength.push(s.rightBoundPlatform.queue.length);\n\n        }\n\n        // train data\n        for (var trainNum = 0; trainNum < trainCount; trainNum++) {\n            data.trains[trainNum].leftDist.push(sst.trainLocation(sst.trains[trainNum]));\n        }\n\n\n    }\n\n    return data;\n\n};\nreturn getSimulationData(hours,route,trains,seed);\n};",
			"file": "sst.js",
			"file_size": 29799,
			"file_write_time": 130094237304179485,
			"settings":
			{
				"buffer_size": 22317,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "bracket highligher\npackage controll\ngosublime\ncodeintel\nlinter\n",
			"settings":
			{
				"buffer_size": 63,
				"line_ending": "Windows",
				"name": "bracket highligher"
			}
		},
		{
			"file": "sst.html",
			"settings":
			{
				"buffer_size": 2467,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 400.0,
		"selected_items":
		[
			[
				"packa",
				"Preferences: Browse Packages"
			]
		],
		"width": 400.0
	},
	"console":
	{
		"height": 125.0,
		"history":
		[
			"cd \\"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/Alec/Desktop/trains1.svg",
		"/C/Users/Alec/AppData/Roaming/Sublime Text 3/Packages/User/Preferences.sublime-settings"
	],
	"find":
	{
		"height": 0.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "sst.js",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22317,
						"regions":
						{
						},
						"selection":
						[
							[
								3728,
								3728
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1907.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 63,
						"regions":
						{
						},
						"selection":
						[
							[
								63,
								63
							]
						],
						"settings":
						{
							"auto_name": "bracket highligher",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "sst.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2467,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/HTML/HTML.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"project": "sst.sublime-project",
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
